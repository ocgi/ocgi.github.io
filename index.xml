<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>OCGI</title><link>https://ocgi.github.io/</link><description>Recent content on OCGI</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><copyright>Copyright © 2021 The OCGI Authors</copyright><lastBuildDate>Wed, 25 Nov 2020 00:00:00 +0000</lastBuildDate><atom:link href="https://ocgi.github.io/index.xml" rel="self" type="application/rss+xml"/><item><title>Carrier SDK</title><link>https://ocgi.github.io/en/docs/reference/sdk/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ocgi.github.io/en/docs/reference/sdk/</guid><description>Background Generally speaking, the game server will cache some player status data locally. During automatic elastic scaling, the Carrier controller cannot create or delete GameServer at will. The Statefulset, Deployment and other workloads provided by K8s lack confirmation with the application when shrinking, changing and deleting Pods.
The GameServer workload provides a simple SDK. The game backend server can notify the Carrier controller of some current service status information, which is used to select the appropriate copy to delete when the Carrier controller elastically expands or releases changes.</description></item><item><title>Carrier SDK</title><link>https://ocgi.github.io/zh/docs/reference/sdk/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ocgi.github.io/zh/docs/reference/sdk/</guid><description>背景 一般来说，游戏后端server会缓存一些玩家状态数据。在自动弹性伸缩的时候，Carrier controller不能随意创建/删除GameServer。K8s提供的Statefulset，Deployment等workload在缩容、变更删除Pod时缺少与应用程序的确认。
而GameServer workload提供了一个简单的SDK，游戏后端server可以把当前的一些服务状态信息，通知到Carrier controller，用于Carrier controller在弹性伸缩、或者发布变更时，选择合适的副本进行删除。
Game server与SDK的关系 SDK-Server作为sidecar容器(由Carrier controller自动注入)，与GameServer容器，运行在同一个K8s pod。 GameServer可以通过SDK API访问SDK-Server。如果应用程序不想调用SDK API，可以配置相应的Webhook，由SDK-Server来调用Webhook。 SDK-Server连接K8s API，并更新GameServer CRD。 用户自定义Condition GameServer可以通过SDK API或者Webhook的方式，设置自定义Condition。
ReadinessGates kind: GameServer ... spec: readinessGates: - network.ocgi.dev/lb-ready status: conditions: - type: &amp;#34;network.ocgi.dev/lb-ready&amp;#34; status: &amp;#34;True&amp;#34; lastProbeTime: null lastTransitionTime: 2018-01-01T00:00:00Z 当Squad在变更时，需要保证所有ReadinessGates Condition都为True，Carrier controller才认为新的副本状态是Ready。
DeletableGates kind: GameServer ... spec: deletableGates: - carrier.ocgi.dev/has-no-player status: conditions: - type: &amp;#34;carrier.ocgi.dev/has-no-player&amp;#34; status: &amp;#34;True&amp;#34; lastProbeTime: null lastTransitionTime: 2018-01-01T00:00:00Z 当Squad在变更，或者缩容时，需要保证DeletableGates Condition都为True，才能删除相应的副本。
GameServer访问SDK Server SDK-Server启动后，会监听一个gRPC和一个HTTP端口，Carrier controller会将端口信息作为环境变量写到GameServer容器：</description></item><item><title>Create a GameServer</title><link>https://ocgi.github.io/en/docs/getting-started/gameserver/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ocgi.github.io/en/docs/getting-started/gameserver/</guid><description>GameServer represents a single game server. It is based on K8s Pod implementation and is a further abstraction of K8s Pod.
Create a GameServer cat &amp;lt;&amp;lt;EOF | kubectl apply -f - apiVersion: &amp;#34;carrier.ocgi.dev/v1alpha1&amp;#34; kind: GameServer metadata: name: &amp;#34;simple-tcp-example&amp;#34; spec: ports: - name: default containerPort: 7654 protocol: TCP template: spec: containers: - name: server image: ocgi/simple-tcp:0.1 resources: requests: memory: &amp;#34;32Mi&amp;#34; cpu: &amp;#34;20m&amp;#34; limits: memory: &amp;#34;32Mi&amp;#34; cpu: &amp;#34;20m&amp;#34; serviceAccount: carrier-sdk serviceAccountName: carrier-sdk EOF Fetch the GameServer Status # kubectl get gs NAME STATE ADDRESS PORT EXTERNALIP PORTRANGE NODE AGE simple-tcp-example Running 172.</description></item><item><title>Squad Introduction</title><link>https://ocgi.github.io/en/docs/guides/squad_details/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ocgi.github.io/en/docs/guides/squad_details/</guid><description>Squad A Squad controller provides declarative update management capabilities for GameServers and GameServerSets. The user can describe the target state in Squad (such as the number of replicas), and the Squad controller will change the actual state according to certain rules, and finally make it reach the desired state.
main feature Manage a group of GameServer Support rolling update Support batch (gray) update Support in-place update Support GameServer auto-scaling Squad update strategy Squad specifies the strategy for updating GameServer through .</description></item><item><title>Squad介绍</title><link>https://ocgi.github.io/zh/docs/guides/squad_details/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ocgi.github.io/zh/docs/guides/squad_details/</guid><description>Squad 一个Squad控制器为GameServers和GameServerSets提供声明式的更新管理能力。用户可以通过描述Squad中的目标状态(例如副本数)，Squad控制器会按照一定的规则更改实际状态，最终使其达到期望的状态。
主要特点 管理一组GameServer 支持滚动更新发布 支持分批（灰度）发布 支持原地更新发布 支持资源自动弹性伸缩 Squad更新策略 Squad通过.spec.strategy来指定更新GameServer的策略。.spec.strategy.type可以是 Recreate、RollingUpdate、CanaryUpdate、或者InplaceUpdate，默认为RollingUpdate
Recreate策略 在创建GameServer前，所有现有的GameServer会被删除掉
RollingUpdate策略 在指定.spec.strategy.type为RollingUpdate时，还可以指定maxUnavailable 和 maxSurge 来控制滚动更过程
maxUnavailable：最大不可用GameServer数。是一个可选字段，用来指定更新过程中不可用的 GameServer 的个数上限。该值可以是绝对数字（例如，5），也可以是所需 GameServer 的百分比（例如，10%）。百分比值会转换成绝对数并去除小数部分。 如果 .spec.strategy.rollingUpdate.maxSurge 为 0，则此值不能为 0。 默认值为 25%
maxSurge: 最大GameServer创建数。是一个可选字段，用来指定可以创建的超出期望 GameServer 个数的 GameServer 数量。此值可以是绝对数（例如，5）或所需 GameServer 的百分比（例如，10%）。 如果 MaxUnavailable 为 0，则此值不能为 0。百分比值会通过向上取整转换为绝对数。 此字段的默认值为 25%。
例如：当此值为25%时，启动滚动更新后，会立即对新的 GameServerSet 扩容，同时保证新旧 GameServer 的总数不超过所需 GameServer 总数的 125%。一旦旧 GameServer 被杀死，新的 GameServerSet 可以进一步扩容， 同时确保更新期间的任何时候运行中的 GameServer 总数最多为所需 GameServer 总数的 125%</description></item><item><title>创建GameServer</title><link>https://ocgi.github.io/zh/docs/getting-started/gameserver/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ocgi.github.io/zh/docs/getting-started/gameserver/</guid><description>GameServer代表单个游戏后端Server。它基于K8s Pod实现，是对K8s Pod的进一步抽象。
创建GameServer cat &amp;lt;&amp;lt;EOF | kubectl apply -f - apiVersion: &amp;#34;carrier.ocgi.dev/v1alpha1&amp;#34; kind: GameServer metadata: name: &amp;#34;simple-tcp-example&amp;#34; spec: ports: - name: default containerPort: 7654 protocol: TCP template: spec: containers: - name: server image: ocgi/simple-tcp:0.1 resources: requests: memory: &amp;#34;32Mi&amp;#34; cpu: &amp;#34;20m&amp;#34; limits: memory: &amp;#34;32Mi&amp;#34; cpu: &amp;#34;20m&amp;#34; serviceAccount: carrier-sdk serviceAccountName: carrier-sdk EOF 查看GameServer信息 # kubectl get gs NAME STATE ADDRESS PORT EXTERNALIP PORTRANGE NODE AGE simple-tcp-example Running 172.16.5.3 172.16.18.47 16s # kubectl get pods NAME READY STATUS RESTARTS AGE simple-tcp-example 2/2 Running 0 48s 各个字段的含义：</description></item><item><title>Create a Squad</title><link>https://ocgi.github.io/en/docs/getting-started/squad/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ocgi.github.io/en/docs/getting-started/squad/</guid><description>Squad represents a group of game servers (GameServer), they have the same resource configuration, and the Carrier controller maintains the specified number of copies of the group of GameServer. It controls the update and scaling of this group of GameServer.
Create a Squad Create a Squad with 2 replicas:
cat &amp;lt;&amp;lt;EOF | kubectl apply -f - apiVersion: carrier.ocgi.dev/v1alpha1 kind: Squad metadata: name: squad-example namespace: default spec: replicas: 2 strategy: rollingUpdate: maxSurge: 1 maxUnavailable: 1 type: RollingUpdate template: metadata: labels: foo: bar spec: ports: - container: server containerPort: 7654 name: default protocol: TCP sdkServer: grpcPort: 9020 httpPort: 9021 logLevel: Info template: spec: containers: - image: ocgi/simple-tcp:0.</description></item><item><title>GeneralPodAutoscaler Introduction</title><link>https://ocgi.github.io/en/docs/guides/gpa/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ocgi.github.io/en/docs/guides/gpa/</guid><description>We can use GeneralPodAutoscaler(GPA) to scale the Pod horizontally. GPA is a component developed based on K8s HPA (v2beta2 api).
GPA feature It does not depend on the K8s version, it can run on K8s 1.8, 1.9, 1.19 and other versions, only the cluster supports CRD; Through GPA&amp;rsquo;s Provider, more external data sources can be supported, including kafka, redis, etc.; Support more scaling modes, with greater flexibility and scalability; GPA upgrades are flexible, and there is no need to restart K8s core components during upgrade.</description></item><item><title>GeneralPodAutoscaler介绍</title><link>https://ocgi.github.io/zh/docs/guides/gpa/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ocgi.github.io/zh/docs/guides/gpa/</guid><description>我们通过GeneralPodAutoscaler(GPA)进行Pod水平伸缩。GPA是基于K8s HPA（v2beta2 api）扩展开发的一个组件。
GPA 特点 不依赖于K8s版本，可以运行于K8s 1.8、1.9、1.19等版本，只需要集群支持CRD; 通过GPA的Provider， 可以支持更多外部数据源，包括kafka, redis等； 支持更多伸缩模式，灵活性、扩展性更强； GPA升级灵活，升级时不需要重启K8s核心组件。 设计 架构 GPA 基于HPA开发的通用Pod扩缩容组件，覆盖了HPA的所有功能。
External Metrics Provider 实现了外部资源的Provider, 可以支持自定义外部资源。
GPA和HPA之间的差异 以下内容为例： 一个workload使用HPA和GPA的yaml差异
HPA apiVersion: autoscaling/v2beta2 kind: HorizontalPodAutoscaler metadata: name: test spec: maxReplicas: 10 minReplicas: 2 metrics: - resource: name: cpu target: averageValue: 20 type: AverageValue type: Resource scaleTargetRef: apiVersion: carrier.ocgi.dev/v1alpha1 kind: Squad name: squad-example1 GPA apiVersion: autoscaling.ocgi.dev/v1alpha1 kind: GeneralPodAutoscaler metadata: name: test spec: maxReplicas: 10 minReplicas: 2 metric: ##difference metrics: - resource: name: cpu target: averageValue: 20 type: AverageValue type: Resource scaleTargetRef: apiVersion: carrier.</description></item><item><title>GPA Webhook example</title><link>https://ocgi.github.io/en/docs/reference/gpa_webhook/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ocgi.github.io/en/docs/reference/gpa_webhook/</guid><description>Introduction GPA(GeneralPodAutoscaler) provides a mechanism based on Webhook to auto-scaling workload. E.g:
apiVersion: autoscaling.ocgi.dev/v1alpha1 kind: GeneralPodAutoscaler metadata: name: pa-squad namespace: default spec: maxReplicas: 8 minReplicas: 1 scaleTargetRef: apiVersion: carrier.ocgi.dev/v1alpha1 kind: Squad name: squad-example webhook: parameters: buffer: &amp;#34;2&amp;#34; service: name: gpa-webhook namespace: kube-system path: scale port: 8000 Webhook Server is implemented by application, so that application can control the number of replicas of workload.
Implement Webhook Server This is a Webhook Server example for Squad.</description></item><item><title>GPA Webhook示例</title><link>https://ocgi.github.io/zh/docs/reference/gpa_webhook/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ocgi.github.io/zh/docs/reference/gpa_webhook/</guid><description>简介 GPA(GeneralPodAutoscaler)提供了基于Webhook的机制来实现Workload的自动伸缩。例如：
apiVersion: autoscaling.ocgi.dev/v1alpha1 kind: GeneralPodAutoscaler metadata: name: pa-squad namespace: default spec: maxReplicas: 8 minReplicas: 1 scaleTargetRef: apiVersion: carrier.ocgi.dev/v1alpha1 kind: Squad name: squad-example webhook: parameters: buffer: &amp;#34;2&amp;#34; service: name: gpa-webhook namespace: kube-system path: scale port: 8000 Webhook Server由用户自己实现，从而实现由用户来控制Workload的副本数量。
实现Webhook Server 这里 是一个针对Squad开发的Webhook Server示例。
Webhook Request and Response Webhook api 定义如下
// AutoscaleRequest defines the request to webhook autoscaler endpoint type AutoscaleRequest struct { // UID is used for tracing the request and response.</description></item><item><title>创建Squad</title><link>https://ocgi.github.io/zh/docs/getting-started/squad/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ocgi.github.io/zh/docs/getting-started/squad/</guid><description>Squad代表一组游戏后端Server(GameServer)，它们具有相同的资源配置，并由Carrier controller维持该组GameServer在指定的副本数量。它控制该组GameServer的发布和更新。
Create a Squad 创建一个2个副本的Squad:
cat &amp;lt;&amp;lt;EOF | kubectl apply -f - apiVersion: carrier.ocgi.dev/v1alpha1 kind: Squad metadata: name: squad-example namespace: default spec: replicas: 2 strategy: rollingUpdate: maxSurge: 1 maxUnavailable: 1 type: RollingUpdate template: metadata: labels: foo: bar spec: ports: - container: server containerPort: 7654 name: default protocol: TCP sdkServer: grpcPort: 9020 httpPort: 9021 logLevel: Info template: spec: containers: - image: ocgi/simple-tcp:0.1 name: server EOF 查看Squad信息 # kubectl get sqd NAME SCHEDULING DESIRED CURRENT UP-TO-DATE READY AGE squad-example MostAllocated 2 2 2 2 4s 其中：</description></item><item><title>Create a GeneralPodAutoscaler</title><link>https://ocgi.github.io/en/docs/getting-started/gpa/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ocgi.github.io/en/docs/getting-started/gpa/</guid><description>GeneralPodAutoscaler (GPA) is fully compatible with the functions of K8s HPA. At the same time, GPA supports Crontab, Webhook and other modes.
Pre-requirement Create a squad.
# cat &amp;lt;&amp;lt;EOF | kubectl apply -f - apiVersion: carrier.ocgi.dev/v1alpha1 kind: Squad metadata: name: squad-example namespace: default spec: replicas: 2 strategy: rollingUpdate: maxSurge: 1 maxUnavailable: 1 type: RollingUpdate template: metadata: labels: foo: squad-example spec: ports: - container: simple-udp containerPort: 7654 hostPort: 7777 name: default portPolicy: Static protocol: UDP sdkServer: grpcPort: 9020 httpPort: 9021 logLevel: Info template: spec: containers: - image: ocgi/simple-tcp:0.</description></item><item><title>Create a GeneralPodAutoscaler</title><link>https://ocgi.github.io/zh/docs/getting-started/gpa/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ocgi.github.io/zh/docs/getting-started/gpa/</guid><description>GeneralPodAutoscaler(GPA)完全兼容K8s HPA的功能。同时，GPA支持Crontab、Webhook等方式。
前置条件 创建一个如下的squad
# cat &amp;lt;&amp;lt;EOF | kubectl apply -f - apiVersion: carrier.ocgi.dev/v1alpha1 kind: Squad metadata: name: squad-example namespace: default spec: replicas: 2 strategy: rollingUpdate: maxSurge: 1 maxUnavailable: 1 type: RollingUpdate template: metadata: labels: foo: squad-example spec: ports: - container: simple-udp containerPort: 7654 hostPort: 7777 name: default portPolicy: Static protocol: UDP sdkServer: grpcPort: 9020 httpPort: 9021 logLevel: Info template: spec: containers: - image: ocgi/simple-tcp:0.1 imagePullPolicy: Always name: server serviceAccount: carrier-sdk serviceAccountName: carrier-sdk EOF 定时扩缩模式 基于Crontab语法，支持多时间段</description></item><item><title>GameServer autoscaling workflow</title><link>https://ocgi.github.io/en/docs/guides/autoscaling_flow/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ocgi.github.io/en/docs/guides/autoscaling_flow/</guid><description>The main flow of GameServer autoscaling is as follows:
The Autoscaler controller calculates a reasonable number of copies of Squad according to the metric information of GameServer;
Carrier selects GameServer according to certain rules, and then sets Constraint to notify the application to offline the copy;
For the GameServer corresponding to RoomAssign offline, set condition offline=true, which means that no new players will be assigned to the GameServer;</description></item><item><title>GameServer自动伸缩流程</title><link>https://ocgi.github.io/zh/docs/guides/autoscaling_flow/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ocgi.github.io/zh/docs/guides/autoscaling_flow/</guid><description>GameServer的autoscaling的详细流程如下：
Autoscaler controller根据GameServer的metric信息，计算Squad的合理副本数量； Carrier根据一定规则选择GameServer，然后设置Constraint，通知应用程序下线该副本； RoomAssign下线对应的GameServer，设置Condition offline=true，表示不再分配新的玩家到该GameServer； GameServer等到没有玩家之后，再设置Condition no-player=true； Carrier controller删除offline=true &amp;amp;&amp;amp; no-player=true的GameServer。 注意，上面的Condition，比如offline，no-player可由业务自己定义。</description></item><item><title>GamerServer scaling down priority</title><link>https://ocgi.github.io/en/docs/guides/squad-scaledown-priority/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ocgi.github.io/en/docs/guides/squad-scaledown-priority/</guid><description>Background Generally speaking, the number of players on each game server will be different. When we scaling down, we can select a replica with fewer users and delete it. In this way, the scaling-down overhead on the application side can be smaller, and at the same time, the utilization efficiency of the underlying resources can be improved.
We can set a certain priority for each game server based on some application metrics.</description></item><item><title>设置GamerServer缩容的优先级</title><link>https://ocgi.github.io/zh/docs/guides/squad-scaledown-priority/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ocgi.github.io/zh/docs/guides/squad-scaledown-priority/</guid><description>背景 一般来说，每个游戏服务器上的玩家数量会不同。当我们缩容时，可以选择用户玩家少的副本，进行删除。这样，可以让应用侧的缩容开销更小，同时，也可以提高底层资源的利用效率。
我们可以根据一些业务侧指标，给每个游戏服务器设置一定的优先级。缩容时，我们选择优先级低的副本删除。
核心方案 给GameServer增加carrier.ocgi.dev/gs-deletion-cost(int64) annotation， annotation可以由用户调用sdk加上，或者由我们的组件cost-server加上。
cost-server根据squad里指定的 carrier.ocgi.dev/gs-cost-metrics-name annotation 从metric server获取数据， 给gs加上carrier.ocgi.dev/gs-deletion-cost annotation。 如果GameServer未设置carrier.ocgi.dev/gs-deletion-cost 按照Int64 Max计算。 如果所有GameServer都未设置，进入原先的逻辑，优先选择节点上GameServer较少的节点上的进行缩容，或者按照创建时间最老进行缩容。 carrier controller，按照该值从小到大顺序排序， 缩容掉top N。
cost-server 简介 cost-serverwatch Squad的创建和更新； cost-server从名为carrier.ocgi.dev/gs-cost-metrics-name的annotation获取对应的metric名； 如果metric是cpu 或者 memory，cost-server将从metric server获取数据；如果是其余metric将从custom metric server获取数据； 最终的数据将会写到GameServer的annotation上，例如：carrier.ocgi. dev/gs-deletion-cost: &amp;quot;2101248000&amp;quot;； 使用方式 如果是使用cpu、memory等指标，用户用只需要在Squad上指定carrier.ocgi.dev/gs-cost-metrics-name； 如果用户需要使用自定义指标，如连接数等，用户可以采用以下2种方式之一： 给Squad加上carrier.ocgi.dev/gs-cost-metrics-name: 连接数, 该方式存在一定延迟 借助SDK的SetAnnotation方法, 给每个GameServer设置carrier.ocgi.dev/gs-deletion-cost 示例 使用cost-server自动给GameServer加cost
创建 squad # cat &amp;lt;&amp;lt;EOF | kubectl apply -f - apiVersion: carrier.</description></item><item><title>Hello, Carrier!</title><link>https://ocgi.github.io/posts/hello/</link><pubDate>Wed, 25 Nov 2020 00:00:00 +0000</pubDate><guid>https://ocgi.github.io/posts/hello/</guid><description>Hello, Carrier!</description></item></channel></rss>